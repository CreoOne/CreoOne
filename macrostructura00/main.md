# Macrostructura 00 - Prologue

## Introduction

Throughout the years i've seen and read many approaches to make perfect software. While everyone's definition of perfect is different from one another, there is that implicit silent consensus in large scale, object oriented, open source world. It would seem like everyone goes into exactly the same destination, from very different origins and by refactorings arrive where everyone else also reached. Still i have not seen a single guide into archiving this destination with as little work as possible. There are bits and pieces scattered across the web, there is a vast knowledge frozen in the depths of public repositories, there is endless hours of video and text tutorials. All this needs to be searched, learned, understood bit by bit.

> If i only could extract this end destination experience for everyone to enjoy.

Thats exactly how idea for _Macrostructura_ was born. Somehow software design patterns and architectural patterns formed, but layer in between and around those - did not. No easy walk-through for You.

This is what im hoping to archive in here, although don't expect this knowledge to be complete. This is only a frame for you to explore. To inspire and lunch into the end goal.

> From smallest concept to largest, one at the time.

## Meta

Ability of a human to name something then describe it to someone else allowed our civilization to progress into realms previously unknown to anyone. We simply build complex systems that are based on centuries of spreading knowledge. Certain humans worked themselves to death without seeing any use of theories they came out with. Today we can teach someone to design something on the computers and they don't need any knowledge about materials, physics, chemistry and others that are used to create computers. We have absurd amounts of abstract layers in hardware and software and going forward we need even more.

> We need abstraction that gives possibilities to tame complexity.

Describing something in simple understandable terms is needed to define patterns. Those patterns can then be used to build mechanisms. Then named combination of those mechanisms can become a pattern.

I try my best to identify and clearly describe patterns for anyone else to use.

## Universality

Whatever will be present in the next chapters in not without it's limitations. Of course i need to restrain myself only to one niche of software development, being object oriented, declarative, almost entirely strongly static typed, classical approach. That is what i know best, that is what i use.

> You may be able to apply this knowledge somewhere else, but i give no guarantee.

Word of warning, what is wrote until this very line seems like an overpromise, but i'll try my best to fulfill it. Which in the end may not be possible, or at least end up being remarkably difficult. Still worth it.